<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: scheduler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: scheduler.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const subscriptionModel = require('./models/subscriptionModel');
const { fetchMultiDayForecast, fetchHourlyForecast } = require('./helpers/fetchMultiDayForecast');
const logger = require('./utils/logger');
const { ForecastFormatterFactory } = require('./src/formatters');
const path = require('path');

// ƒÆkeliamas failo vardas log'uose
const { name } = path.parse(__filename);
const SCHEDULE_HOUR = 14;
const SCHEDULE_MINUTE = 26;

// Konfig≈´ruojami laikai kiekvienam prenumeratos tipui
const scheduleTimes = {
  morning: {
    hour: parseInt(process.env.SCHEDULE_MORNING_HOUR) || 8,
    minute: parseInt(process.env.SCHEDULE_MORNING_MINUTE) || 0
  },
  weekly: {
    hour: parseInt(process.env.SCHEDULE_WEEKLY_HOUR) || 8,
    minute: parseInt(process.env.SCHEDULE_WEEKLY_MINUTE) || 0,
    day: parseInt(process.env.SCHEDULE_WEEKLY_DAY) || 1 // 1 = pirmadienis
  },
  thrice_daily: {
    hours: (process.env.SCHEDULE_THRICE_HOURS || '8,15,19').split(',').map(h => parseInt(h, 10)),
    minute: parseInt(process.env.SCHEDULE_THRICE_MINUTE) || 0
  }
};

/**
 * Formatuoja or≈≥ prognozƒô pagal prenumeratos tipƒÖ
 * @param {Object} weatherData - Or≈≥ duomenys i≈° API
 * @param {Object} sub - Prenumeratos duomenys
 * @returns {Promise&lt;string>} Suformatuotas prane≈°imas
 */
async function formatForecastBySubscription(weatherData, sub) {
  try {
    // Patikriname ar gauname teisingus duomenis
    if (!weatherData?.list || !Array.isArray(weatherData.list) || weatherData.list.length === 0) {
      logger.error('Netinkamas or≈≥ duomen≈≥ formatas', {
        hasList: !!weatherData?.list,
        isArray: Array.isArray(weatherData?.list),
        listLength: weatherData?.list?.length
      });
      return 'Nepavyko gauti or≈≥ duomen≈≥: neteisingas duomen≈≥ formatas';
    }

    const isTest = sub.telegram_id?.startsWith('TEST_');

    let subscriptionType = 'weekly';
    if (sub.morning_forecast) {
      subscriptionType = 'morning';
    } else if (sub.daily_thrice_forecast) {
      subscriptionType = 'thrice_daily';
    }
    logger.debug(`Formatuojama prognozƒó vartotojui ${sub.telegram_id}, miestas: ${sub.city}`, {
      forecastCount: weatherData.list.length,
      subscriptionType
    });

    // Nustatome prane≈°imo tipƒÖ
    let forecastType = subscriptionType;

    // Sukuriame tinkamƒÖ formatuotojƒÖ
    let formatter;
    try {
      formatter = ForecastFormatterFactory.create(
        forecastType,
        weatherData,
        {
          locale: 'lt-LT',
          timezone: 'Europe/Vilnius',
          isTest
        }
      );
    } catch (e) {
      logger.error('Nepavyko sukurti formatuotojo objektui:', forecastType, e);
      return 'Nepavyko suformuoti prane≈°imo.';
    }
    if (!formatter) {
      logger.error('Nepavyko sukurti formatuotojo objektui:', forecastType);
      return 'Nepavyko suformuoti prane≈°imo.';
    }

    // GrƒÖ≈æiname suformatuotƒÖ prane≈°imƒÖ
    return formatter.format();
  } catch (error) {
    logger.error('Kritinƒó klaida formuojant prognozƒô:', error);
    return 'ƒÆvyko klaida formuojant or≈≥ prognozƒô. Bandykite vƒóliau.';
  }
}

// Funkcija, kuri tikrina prenumeratas ir siunƒçia prane≈°imus
async function checkAndSendForecasts(bot, isTestRun = false) {
  logger.info(`Scheduler: Tikrinamos prenumeratos... ${isTestRun ? '(Testinis paleidimas)' : ''}`);
  try {
    const subscriptions = await subscriptionModel.getAllSubscriptions();
    if (subscriptions.length === 0) {
      logger.info('Scheduler: Nƒóra aktyvi≈≥ prenumerat≈≥, praleid≈æiama.');
      return;
    }

    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const currentDay = now.getDay();

    for (const sub of subscriptions) {
      let shouldSend = false;
      let subType = null;
      if (isTestRun) {
        shouldSend = true;
      } else if (
        sub.morning_forecast &amp;&amp;
        currentHour === scheduleTimes.morning.hour &amp;&amp;
        currentMinute === scheduleTimes.morning.minute
      ) {
        shouldSend = true;
        subType = 'morning';
      } else if (
        sub.weekly_forecast &amp;&amp;
        currentHour === scheduleTimes.weekly.hour &amp;&amp;
        currentMinute === scheduleTimes.weekly.minute &amp;&amp;
        currentDay === scheduleTimes.weekly.day
      ) {
        shouldSend = true;
        subType = 'weekly';
      } else if (
        sub.daily_thrice_forecast &amp;&amp;
        scheduleTimes.thrice_daily.hours.includes(currentHour) &amp;&amp;
        currentMinute === scheduleTimes.thrice_daily.minute
      ) {
        shouldSend = true;
        subType = 'thrice_daily';
      }

      if (shouldSend) {
        logger.info(`Scheduler: Siunƒçiama prognozƒó vartotojui ${sub.telegram_id} miestui ${sub.city}`);
        try {
          let weatherData;
          if (subType === 'morning' || subType === 'thrice_daily') {
            const cnt = Math.max(0, Math.ceil((24 - currentHour) / 3));
            weatherData = await fetchHourlyForecast(sub.city, cnt);
          } else if (subType === 'weekly') {
            weatherData = await fetchMultiDayForecast(sub.city);
          } else {
            const cnt = Math.max(0, Math.ceil((24 - currentHour) / 3));
            weatherData = await fetchHourlyForecast(sub.city, cnt);
          }

          if (!weatherData) {
            logger.error(`Scheduler: Gauti tu≈°ti or≈≥ duomenys miestui ${sub.city}`);
            continue;
          }
          if (!weatherData.list || !Array.isArray(weatherData.list)) {
            logger.error(`Scheduler: Neteisingas or≈≥ duomen≈≥ formatas miestui ${sub.city}:`, JSON.stringify(weatherData).substring(0, 200));
            continue;
          }
          logger.info(`Scheduler: Sƒókmingai gauti or≈≥ duomenys miestui ${sub.city}, rasta ƒØra≈°≈≥: ${weatherData.list.length}`);

          // Siunƒçiame tik tƒÖ prenumeratos tipƒÖ, kuris atitinka dabartinƒØ laikƒÖ
          if (
            (subType === 'morning' &amp;&amp; sub.morning_forecast) ||
            (subType === 'thrice_daily' &amp;&amp; sub.daily_thrice_forecast) ||
            (subType === 'weekly' &amp;&amp; sub.weekly_forecast)
          ) {
            await sendSubscriptionMessage(bot, sub, weatherData, subType, '');
          } else {
            logger.info(`Scheduler: Vartotojui ${sub.telegram_id} (${sub.city}) neatitinka prenumeratos tipas, prane≈°imas nesiunƒçiamas.`);
          }
        } catch (error) {
          logger.error(`Scheduler: Klaida siunƒçiant prognozƒô vartotojui ${sub.telegram_id}:`, error);
        }
        // 1 sek delay tarp naudotoj≈≥ (rate limit)
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  } catch (error) {
    logger.error('Scheduler: Klaida gaunant prenumeratas:', error);
  }
  logger.info(`Scheduler: Prenumerat≈≥ tikrinimas baigtas. ${isTestRun ? '(Testinis paleidimas)' : ''}`);
}

/**
 * Helper function to send subscription messages based on subscription type
 * @param {Object} bot - Telegram bot instance
 * @param {Object} sub - Subscription data
 * @param {Object} weatherData - Weather data
 * @param {string} subType - Subscription type ('morning', 'thrice_daily', 'weekly')
 * @param {string} header - Message header
 * @returns {Promise&lt;boolean>} True if message was sent successfully
 */
async function sendSubscriptionMessage(bot, sub, weatherData, subType, header = '') {
  let chatId = sub.chat_id || sub.telegram_id;
  if (!chatId) {
    logger.error(`Nenurodytas chat_id vartotojui: ${JSON.stringify(sub)}`);
    return false;
  }
  try {
    // Create a temporary subscription object for the specific type
    const tempSub = {
      ...sub,
      morning_forecast: subType === 'morning',
      daily_thrice_forecast: subType === 'thrice_daily',
      weekly_forecast: subType === 'weekly',
      chat_id: chatId,
      telegram_id: sub.telegram_id || chatId // Ensure telegram_id is set
    };
    logger.info(`Formatuojamas ${subType} prane≈°imas vartotojui ${sub.telegram_id} (${sub.city})`);
    // Format the message using the appropriate formatter
    const message = await formatForecastBySubscription(weatherData, tempSub);
    // Handle both string and array of message parts
    const messages = Array.isArray(message) ? message : [message];
    logger.info(`Siunƒçiamas ${subType} prane≈°imas vartotojui ${chatId} (${sub.city})`);
    // Pridedame prenumeratos tipƒÖ ir miesto pavadinimƒÖ prie kiekvienos ≈æinutƒós
    let typeLabel = '';
    if (subType === 'morning') typeLabel = 'üåÖ Rytinƒó';
    else if (subType === 'thrice_daily') typeLabel = 'Dienos prognozƒó';
    else if (subType === 'weekly') typeLabel = 'Savaitƒós prognozƒó';
    const cityName = weatherData.city?.name || sub.city || '';
    for (const msg of messages) {
      const fullMsg = `&lt;b>${typeLabel}&lt;/b>\n&lt;b>${cityName}&lt;/b>\n${msg}`;
      await bot.sendMessage(chatId, fullMsg, { parse_mode: 'HTML' });
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    logger.info(`${subType} prane≈°imas sƒókmingai i≈°si≈≥stas vartotojui ${sub.telegram_id} miestui ${sub.city}`);
    return true;
  } catch (error) {
    logger.error(`Klaida siunƒçiant ${subType} prane≈°imƒÖ vartotojui ${sub.telegram_id}:`, error);
    try {
      await bot.sendMessage(chatId, 'ƒÆvyko klaida siunƒçiant prognozƒô. Bandykite vƒóliau.');
    } catch (e) {
      logger.error('Nepavyko i≈°si≈≥sti klaidos prane≈°imo:', e);
    }
    return false;
  }
}

/**
 * Testinƒó funkcija, kuri imituoja tikrƒÖ prane≈°im≈≥ siuntimƒÖ pagal vartotoj≈≥ prenumeratas
 * @param {Object} bot - Telegram bot objektas
 */
async function testAllSubscriptionTypes(bot) {
  logger.info('Pradedamas tikr≈≥ prenumerat≈≥ testavimas...');
  
  try {
    // Gauname visas prenumeratas i≈° duomen≈≥ bazƒós
    const subscriptions = await subscriptionModel.getAllSubscriptions();
    
    if (subscriptions.length === 0) {
      logger.info('Nerasta joki≈≥ prenumerat≈≥ testavimui');
      return;
    }
    
    logger.info(`Radome ${subscriptions.length} prenumerat≈≥ testavimui`);
    
    // Grupuojame prenumeratas pagal vartotojƒÖ ir miestƒÖ
    const subscriptionsByUser = {};
    
    subscriptions.forEach(sub => {
      const key = `${sub.telegram_id}_${sub.city.toLowerCase()}`;
      if (!subscriptionsByUser[key]) {
        subscriptionsByUser[key] = {
          telegram_id: sub.telegram_id,
          chat_id: sub.telegram_id, // Naudojame tƒÖ patƒØ ID kaip ir chat_id
          city: sub.city,
          morning_forecast: false,
          weekly_forecast: false,
          daily_thrice_forecast: false,
          isTest: true
        };
      }
      
      // Nustatome prenumeratos tipƒÖ
      if (sub.morning_forecast) subscriptionsByUser[key].morning_forecast = true;
      if (sub.weekly_forecast) subscriptionsByUser[key].weekly_forecast = true;
      if (sub.daily_thrice_forecast) subscriptionsByUser[key].daily_thrice_forecast = true;
    });
    
    const userSubscriptions = Object.values(subscriptionsByUser);
    logger.info(`Surinkta ${userSubscriptions.length} unikali≈≥ vartotoj≈≥ ir miest≈≥ kombinacij≈≥`);
    
    // Siunƒçiame prane≈°imus kiekvienam vartotojui pagal jo prenumeratƒÖ
    for (const sub of userSubscriptions) {
      try {
        logger.info(`Tikrinama prenumerata vartotojui ${sub.telegram_id}, miestas: ${sub.city}`);
        
        try {
          let weatherData;
          const now = new Date();
          const currentHour = now.getHours();
          // For each type, fetch the correct data
          if (sub.morning_forecast) {
            const cnt = Math.max(0, Math.ceil((24 - currentHour) / 3));
            weatherData = await fetchHourlyForecast(sub.city, cnt);
            await sendSubscriptionMessage(bot, sub, weatherData, 'morning', '*üîπ TESTINIS PRANE≈†IMAS*\n');
          }
          if (sub.daily_thrice_forecast) {
            const cnt = Math.max(0, Math.ceil((24 - currentHour) / 3));
            weatherData = await fetchHourlyForecast(sub.city, cnt);
            await sendSubscriptionMessage(bot, sub, weatherData, 'thrice_daily', '*üîπ TESTINIS PRANE≈†IMAS*\n');
          }
          if (sub.weekly_forecast) {
            weatherData = await fetchMultiDayForecast(sub.city);
            await sendSubscriptionMessage(bot, sub, weatherData, 'weekly', '*üîπ TESTINIS PRANE≈†IMAS*\n');
          }
        } catch (fetchError) {
          logger.error(`Klaida gaunant or≈≥ duomenis vartotojui ${sub.telegram_id} (${sub.city}):`, {
            message: fetchError.message,
            stack: fetchError.stack,
            response: fetchError.response?.data
          });
        }
      } catch (error) {
        logger.error(`Netikƒóta klaida apdorojant prenumeratƒÖ vartotojui ${sub.telegram_id} (${sub.city}):`, {
          message: error.message,
          stack: error.stack,
          error: error
        });
      }
    }
    
    logger.info('Visi testiniai prane≈°imai sƒókmingai i≈°si≈≥sti pagal vartotoj≈≥ prenumeratas.');
    
  } catch (error) {
    logger.error('Kritinƒó klaida vykdant testinƒØ prane≈°im≈≥ siuntimƒÖ:', error);
  }
}

// Eksportuojame funkcijƒÖ, kuri paleid≈æia planuotojƒÖ
module.exports = {
  start: (bot) => {
    if (process.env.RUN_TESTS === 'true') {
      logger.info('Scheduler: Testinis prane≈°im≈≥ siuntimas pagal vartotoj≈≥ prenumeratas numatytas po 5 sekund≈æi≈≥.');
      setTimeout(() => testAllSubscriptionTypes(bot), 5000);
      return;
    }
    setInterval(() => {
      const now = new Date();
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();
      const currentDay = now.getDay();
      // Tikriname visus prenumeratos tipus
      if (
        currentHour === scheduleTimes.morning.hour &amp;&amp;
        currentMinute === scheduleTimes.morning.minute
      ) {
        checkAndSendForecasts(bot, false);
      }
      if (
        currentHour === scheduleTimes.weekly.hour &amp;&amp;
        currentMinute === scheduleTimes.weekly.minute &amp;&amp;
        currentDay === scheduleTimes.weekly.day
      ) {
        checkAndSendForecasts(bot, false);
      }
      if (
        scheduleTimes.thrice_daily.hours.includes(currentHour) &amp;&amp;
        currentMinute === scheduleTimes.thrice_daily.minute
      ) {
        checkAndSendForecasts(bot, false);
      }
    }, 60000); // Tikriname kas minutƒô
    logger.info(`Scheduler: Planuotojas paleistas. Laikai: Ryto: ${scheduleTimes.morning.hour}:${scheduleTimes.morning.minute}, Savaitƒós: ${scheduleTimes.weekly.hour}:${scheduleTimes.weekly.minute} (${scheduleTimes.weekly.day}), Triskart: ${scheduleTimes.thrice_daily.hours.join(',')}:${scheduleTimes.thrice_daily.minute}`);
    // Paleid≈æiame i≈° karto, jei atitinka bet kurƒØ laikƒÖ
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    const currentDay = now.getDay();
    if (
      (currentHour === scheduleTimes.morning.hour &amp;&amp; currentMinute === scheduleTimes.morning.minute) ||
      (currentHour === scheduleTimes.weekly.hour &amp;&amp; currentMinute === scheduleTimes.weekly.minute &amp;&amp; currentDay === scheduleTimes.weekly.day) ||
      (scheduleTimes.thrice_daily.hours.includes(currentHour) &amp;&amp; currentMinute === scheduleTimes.thrice_daily.minute)
    ) {
      checkAndSendForecasts(bot, false);
    }
  },
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#clearChat">clearChat</a></li><li><a href="global.html#formatForecastBySubscription">formatForecastBySubscription</a></li><li><a href="global.html#sendSubscriptionMessage">sendSubscriptionMessage</a></li><li><a href="global.html#testAllSubscriptionTypes">testAllSubscriptionTypes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Jun 13 2025 11:02:58 GMT+0300 (–í–æ—Å—Ç–æ—á–Ω–∞—è –ï–≤—Ä–æ–ø–∞, –ª–µ—Ç–Ω–µ–µ –≤—Ä–µ–º—è)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
